# 订单验证系统快速集成指南

## 概述

本文档提供了订单参数验证系统的快速集成指南，帮助开发者快速上手并正确使用新的验证功能。

## 快速开始

### 1. 基本验证示例

```typescript
import { validateOrderCreation, validateOrderUpdate } from '@/lib/order-validator';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    
    // 验证创建订单参数
    const result = validateOrderCreation(body);
    
    if (!result.isValid) {
      return NextResponse.json(
        formatValidationErrorResponse(result),
        { status: 400 }
      );
    }

    // 验证成功，使用清理后的数据
    const orderData = result.sanitizedData;
    
    // 执行订单创建逻辑...
    return NextResponse.json({
      success: true,
      data: orderData
    });

  } catch (error) {
    return NextResponse.json(
      { success: false, error: error.message },
      { status: 500 }
    );
  }
}
```

### 2. 使用中间件

```typescript
import { ORDER_VALIDATION_MIDDLEWARES } from '@/lib/order-validation-middleware';

export async function POST(request: NextRequest) {
  return await ORDER_VALIDATION_MIDDLEWARES.create(request, async (req, validatedData) => {
    // 这里的数据已经过验证和清理
    try {
      // 认证检查
      const authHeader = req.headers.get('authorization');
      if (!authHeader) {
        return NextResponse.json({ error: '需要认证' }, { status: 401 });
      }

      // 执行业务逻辑
      const order = await createOrder(validatedData);
      
      return NextResponse.json({
        success: true,
        data: order
      });

    } catch (error) {
      return NextResponse.json(
        { success: false, error: error.message },
        { status: 500 }
      );
    }
  });
}
```

### 3. 使用装饰器

```typescript
import { withOrderValidation } from '@/lib/order-validation-middleware';

class OrderController {
  @withOrderValidation('create')
  async createOrder(req: NextRequest, validatedData: any) {
    // validatedData 已经过验证和清理
    const order = await createOrder(validatedData);
    
    return NextResponse.json({
      success: true,
      data: order
    });
  }

  @withOrderValidation('update')
  async updateOrder(req: NextRequest, validatedData: any) {
    const order = await updateOrder(validatedData);
    
    return NextResponse.json({
      success: true,
      data: order
    });
  }

  @withOrderValidation('query')
  async queryOrders(req: NextRequest, validatedData: any) {
    const orders = await getOrders(validatedData);
    
    return NextResponse.json({
      success: true,
      data: orders
    });
  }
}
```

## 常用验证场景

### 创建订单验证

```typescript
// 基础创建订单
const result = validateOrderCreation({
  userId: '123e4567-e89b-12d3-a456-426614174000',
  productId: '123e4567-e89b-12d3-a456-426614174001',
  type: 'direct_buy',
  quantity: 2,
  totalAmount: 99.99,
  paymentMethod: 'balance'
});

// 转售订单
const resaleResult = validateOrderCreation({
  userId: '123e4567-e89b-12d3-a456-426614174000',
  type: 'resale',
  isResale: true,
  resalePrice: 120.00,
  quantity: 1,
  totalAmount: 120.00
});
```

### 更新订单验证

```typescript
// 更新订单状态
const result = validateOrderUpdate({
  id: '123e4567-e89b-12d3-a456-426614174000',
  status: 'confirmed'
});

// 更新跟踪号
const trackingResult = validateOrderUpdate({
  id: '123e4567-e89b-12d3-a456-426614174000',
  trackingNumber: 'SF1234567890',
  notes: '已发货，请注意查收'
});
```

### 查询订单验证

```typescript
// 查询订单列表
const queryResult = validateOrderQuery({
  page: 1,
  limit: 20,
  status: 'pending',
  type: 'direct_buy',
  startDate: '2025-10-01',
  endDate: '2025-10-31'
});
```

## 高级配置

### 1. 自定义约束

```typescript
import { OrderValidator, DEFAULT_CONSTRAINTS } from '@/lib/order-validator';

const customValidator = new OrderValidator({
  constraints: {
    ...DEFAULT_CONSTRAINTS,
    minAmount: 10.00,        // 最小金额10元
    maxAmount: 50000.00,     // 最大金额5万元
    maxQuantity: 100,        // 最多100个
    allowZeroAmounts: true,  // 允许0金额（退款场景）
    maxNotesLength: 1000     // 允许1000字符备注
  },
  regexValidators: {
    // 自定义正则表达式
    orderNumber: /^[A-Z0-9]{6,20}$/, // 自定义订单号格式
    trackingNumber: /^[A-Z0-9\-]{10,30}$/
  }
});
```

### 2. 管理员专用验证

```typescript
const adminValidator = new OrderValidator({
  strict: false,                    // 宽松模式
  allowUnknownFields: true,         // 允许未知字段
  constraints: {
    ...DEFAULT_CONSTRAINTS,
    minAmount: 0,                   // 允许负数（退款）
    maxAmount: 9999999.99,          // 更大金额范围
    decimalPlaces: 4,               // 更多小数位
    maxQuantity: 100000,            // 更大数量限制
    allowNegativeAmounts: true,     // 允许负金额
    allowZeroAmounts: true,         // 允许零金额
    maxNotesLength: 5000            // 更长备注
  }
});
```

### 3. 特定业务场景验证

```typescript
// 转售订单专用验证
const resaleValidator = new OrderValidator({
  constraints: {
    ...DEFAULT_CONSTRAINTS,
    minAmount: 0.01,
    maxAmount: 99999.99,
    minQuantity: 1,
    maxQuantity: 1,                 // 转售只能单个
    allowNegativeAmounts: false,
    allowZeroAmounts: false
  }
});

// 检查转售特殊要求
const resaleData = {
  userId: '123e4567-e89b-12d3-a456-426614174000',
  type: 'resale',
  isResale: true,
  resalePrice: 120.00,
  quantity: 1
};

const result = resaleValidator.validateOrderCreation(resaleData);

// 额外业务逻辑检查
if (result.isValid) {
  if (result.sanitizedData.type !== 'resale') {
    result.errors.push(ErrorFactory.createValidationError('必须是转售订单类型', 'type'));
  }
  
  if (!result.sanitizedData.isResale) {
    result.errors.push(ErrorFactory.createValidationError('isResale必须为true', 'isResale'));
  }
}
```

## 错误处理

### 1. 错误响应格式

```typescript
function handleValidationError(result: ValidationResult) {
  const errorMessages = result.errors.map(e => e.message);
  
  return NextResponse.json({
    success: false,
    error: '订单参数验证失败',
    details: errorMessages.join('; '),
    validationErrors: result.errors.map(e => ({
      field: e.details?.field,
      message: e.message,
      value: e.details?.value
    })),
    warnings: result.warnings,
    timestamp: new Date().toISOString()
  }, { status: 400 });
}
```

### 2. 批量错误处理

```typescript
export async function POST_batch_orders(request: NextRequest) {
  try {
    const body = await request.json();
    const { orders } = body;

    if (!Array.isArray(orders) || orders.length === 0) {
      return NextResponse.json(
        { success: false, error: '订单列表不能为空' },
        { status: 400 }
      );
    }

    // 批量验证
    const results = orders.map((order, index) => {
      const result = validateOrderUpdate(order);
      return { index, orderId: order.id, ...result };
    });

    const validOrders = results.filter(r => r.isValid);
    const invalidOrders = results.filter(r => !r.isValid);

    if (invalidOrders.length > 0) {
      return NextResponse.json({
        success: false,
        error: '部分订单参数验证失败',
        summary: {
          total: orders.length,
          valid: validOrders.length,
          invalid: invalidOrders.length
        },
        invalidOrders: invalidOrders.map(r => ({
          orderId: r.orderId,
          index: r.index,
          errors: r.errors.map(e => e.message)
        }))
      }, { status: 400 });
    }

    // 执行批量操作...
    return NextResponse.json({
      success: true,
      message: '批量操作完成',
      processed: validOrders.length
    });

  } catch (error) {
    return NextResponse.json(
      { success: false, error: error.message },
      { status: 500 }
    );
  }
}
```

## 最佳实践

### 1. 认证和授权

```typescript
export async function POST(request: NextRequest) {
  // 认证检查
  const authHeader = request.headers.get('authorization');
  if (!authHeader) {
    return NextResponse.json(CommonErrors.unauthorized(), { status: 401 });
  }

  // 验证令牌
  try {
    const token = authHeader.substring(7);
    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as { userId: string };
    
    // 验证订单数据
    const body = await request.json();
    const result = validateOrderCreation(body);

    if (!result.isValid) {
      return handleValidationError(result);
    }

    // 检查权限（只能创建自己的订单）
    if (decoded.userId !== result.sanitizedData.userId) {
      return NextResponse.json(CommonErrors.forbidden(), { status: 403 });
    }

    // 执行业务逻辑...
    
  } catch (error) {
    return NextResponse.json(CommonErrors.unauthorized(), { status: 401 });
  }
}
```

### 2. 事务处理

```typescript
export async function POST(request: NextRequest) {
  return await ORDER_VALIDATION_MIDDLEWARES.create(request, async (req, validatedData) => {
    try {
      return await prisma.$transaction(async (tx) => {
        // 创建订单
        const order = await tx.orders.create({
          data: {
            orderNumber: generateOrderNumber(),
            userId: validatedData.userId,
            productId: validatedData.productId,
            type: validatedData.type,
            quantity: validatedData.quantity,
            totalAmount: validatedData.totalAmount
          }
        });

        // 更新用户余额
        await tx.users.update({
          where: { id: validatedData.userId },
          data: { 
            balance: { decrement: validatedData.totalAmount },
            totalSpent: { increment: validatedData.totalAmount }
          }
        });

        // 创建交易记录
        await tx.transactions.create({
          data: {
            userId: validatedData.userId,
            type: validatedData.type,
            amount: -validatedData.totalAmount,
            balanceType: 'balance',
            relatedOrderId: order.id
          }
        });

        return NextResponse.json({
          success: true,
          data: order
        });
      });

    } catch (error) {
      return NextResponse.json(
        { success: false, error: error.message },
        { status: 500 }
      );
    }
  });
}
```

### 3. 监控和日志

```typescript
export async function POST(request: NextRequest) {
  const logger = getLogger();
  const monitor = getMonitor();

  try {
    const body = await request.json();
    const result = validateOrderCreation(body);

    // 记录验证指标
    monitor.increment('order_validation_total', 1, {
      result: result.isValid ? 'success' : 'failure',
      type: body.type
    });

    if (!result.isValid) {
      // 记录验证失败日志
      logger.warn('订单创建验证失败', {
        userId: body.userId,
        errors: result.errors.map(e => ({
          field: e.details?.field,
          message: e.message
        })),
        userAgent: request.headers.get('user-agent'),
        ip: request.headers.get('x-forwarded-for')
      });

      return handleValidationError(result);
    }

    // 验证成功日志
    logger.info('订单创建验证通过', {
      userId: result.sanitizedData.userId,
      orderType: result.sanitizedData.type,
      amount: result.sanitizedData.totalAmount
    });

    // 执行业务逻辑...
    
  } catch (error) {
    logger.error('订单创建异常', error as Error, {
      url: request.url,
      method: request.method
    });

    return NextResponse.json(
      { success: false, error: '服务器内部错误' },
      { status: 500 }
    );
  }
}
```

## 常见问题

### Q: 如何处理自定义验证规则？

A: 可以继承OrderValidator类并重写相应的验证方法：

```typescript
class CustomOrderValidator extends OrderValidator {
  protected validateBusinessRules(data: any, errors: ValidationError[], warnings: string[]): void {
    super.validateBusinessRules(data, errors, warnings);
    
    // 添加自定义验证逻辑
    if (data.type === 'premium' && data.totalAmount < 1000) {
      errors.push(ErrorFactory.createValidationError(
        '高级订单最小金额为1000元',
        'totalAmount'
      ));
    }
  }
}
```

### Q: 如何跳过某些字段的验证？

A: 在自定义验证器中重写字段验证方法：

```typescript
class SkipFieldValidator extends OrderValidator {
  private skipFields: string[] = [];

  constructor(skipFields: string[], options: Partial<ValidationOptions> = {}) {
    super(options);
    this.skipFields = skipFields;
  }

  protected validateRequiredFields(data: any, errors: ValidationError[]): void {
    const requiredFields = ['userId', 'type'].filter(field => 
      !this.skipFields.includes(field)
    );
    
    // 验证剩余的必填字段
    // ...
  }
}
```

### Q: 如何添加实时验证建议？

A: 可以扩展验证器提供建议功能：

```typescript
class SuggestiveOrderValidator extends OrderValidator {
  validateWithSuggestions(data: any) {
    const result = this.validateOrderCreation(data);
    const suggestions = [];

    // 金额建议
    if (data.totalAmount < 10) {
      suggestions.push('建议设置最小金额为10元以确保订单有效性');
    }

    // 数量建议
    if (data.quantity > 10) {
      suggestions.push('大量采购请联系客服享受批发价格');
    }

    return {
      ...result,
      suggestions
    };
  }
}
```

## 性能优化

### 1. 缓存验证结果

```typescript
const validationCache = new Map();

function cachedValidateOrderCreation(data: any) {
  const cacheKey = JSON.stringify(data);
  
  if (validationCache.has(cacheKey)) {
    return validationCache.get(cacheKey);
  }

  const result = validateOrderCreation(data);
  
  // 缓存结果（设置过期时间）
  validationCache.set(cacheKey, result);
  
  return result;
}
```

### 2. 异步验证

```typescript
async function asyncValidateOrderCreation(data: any) {
  // 对于复杂的验证逻辑，使用异步处理
  return new Promise((resolve) => {
    setImmediate(() => {
      const result = validateOrderCreation(data);
      resolve(result);
    });
  });
}
```

## 版本兼容性

- **Node.js**: >= 16.0.0
- **Next.js**: >= 13.0.0  
- **TypeScript**: >= 4.5.0
- **Prisma**: 兼容所有版本

## 总结

通过本指南，您应该能够：

1. ✅ 快速集成订单验证系统
2. ✅ 理解不同验证方式的使用场景
3. ✅ 配置自定义验证约束
4. ✅ 正确处理验证错误
5. ✅ 应用最佳实践

如需更多帮助，请参考详细的API文档和示例代码。
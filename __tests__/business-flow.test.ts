import { describe, test, expect, beforeAll, afterAll, beforeEach } from '@jest/globals';
import { prisma } from '../lib/prisma';
import DatabaseLockManager from '../lib/database-lock-manager';
import { performSecureDraw } from '../lib/lottery-algorithm';
/**
 * Ê†∏ÂøÉ‰∏öÂä°ÊµÅÁ®ãÂçïÂÖÉÊµãËØï
 * ÊµãËØïÁî®Êà∑Ê≥®ÂÜå„ÄÅÂ§∫ÂÆùÂèÇ‰∏é„ÄÅËÆ¢ÂçïÁÆ°ÁêÜÁ≠âÂÖ≥ÈîÆ‰∏öÂä°ÈÄªËæë
 */


describe('Ê†∏ÂøÉ‰∏öÂä°ÊµÅÁ®ãÊµãËØï', () => {
  const TEST_USER_ID = 'test-business-user';
  const TEST_PRODUCT_ID = 'test-business-product';
  const TEST_ROUND_ID = 'test-business-round';

  beforeAll(async () => {
    console.log('üèóÔ∏è  ÂáÜÂ§á‰∏öÂä°ÊµãËØïÊï∞ÊçÆ...');
    await setupBusinessTestData();
  });

  afterAll(async () => {
    console.log('üßπ Ê∏ÖÁêÜ‰∏öÂä°ÊµãËØïÊï∞ÊçÆ...');
    await cleanupBusinessTestData();
  });

  beforeEach(async () => {
    // ÊØè‰∏™ÊµãËØïÂâçÈáçÁΩÆÊï∞ÊçÆ
    await resetBusinessTestData();
  });

  describe('Áî®Êà∑Ê≥®ÂÜåÊµÅÁ®ãÊµãËØï', () => {
    test('Êñ∞Áî®Êà∑Ê≥®ÂÜåÂ∫îËØ•ÊàêÂäü', async () => {
      const newUserId = `new-user-${Date.now()}`;
      const telegramId = `new_telegram_${Date.now()}`;

      // ÂàõÂª∫Êñ∞Áî®Êà∑
      const user = await prisma.users.create({
        data: {
          id: newUserId,
          telegramId: telegramId,
          firstName: 'New User',
          language: 'zh',
          balance: 50, // È¶ñÊ¨°Ê≥®ÂÜåËµ†ÈÄÅ50Â§∫ÂÆùÂ∏Å
          platformBalance: 0,
          freeDailyCount: 3,
          lastFreeResetDate: new Date()
        }
      });

      expect(user).toBeDefined();
      expect(user.id).toBe(newUserId);
      expect(user.balance).toBe(50);
      expect(user.freeDailyCount).toBe(3);

      // È™åËØÅ‰∫§ÊòìËÆ∞ÂΩï
      const transaction = await prisma.transactions.findFirst({
        where: {
          userId: newUserId,
          type: 'register_bonus'
        }
      });

      expect(transaction).toBeDefined();
      expect(transaction?.amount).toBe(50);
    });

    test('ÈáçÂ§çÊ≥®ÂÜåÂ∫îËØ•Êõ¥Êñ∞Áî®Êà∑‰ø°ÊÅØ', async () => {
      // Ê®°ÊãüTelegramÁî®Êà∑ÈáçÊñ∞Ê≥®ÂÜå
      const updatedFirstName = 'Updated User Name';
      const updatedLanguage = 'en';

      const user = await prisma.users.upsert({
        where: { id: TEST_USER_ID },
        update: {
          firstName: updatedFirstName,
          language: updatedLanguage
        },
        create: {
          id: TEST_USER_ID,
          telegramId: 'test_telegram_business',
          firstName: updatedFirstName,
          language: updatedLanguage,
          balance: 50
        }
      });

      expect(user.firstName).toBe(updatedFirstName);
      expect(user.language).toBe(updatedLanguage);
    });

    test('Ê≥®ÂÜåÊó∂Â∫îËØ•Ëá™Âä®ÈáçÁΩÆÂÖçË¥πÊ¨°Êï∞', async () => {
      // ËÆæÁΩÆÊóßÁöÑÂÖçË¥πÊ¨°Êï∞ÈáçÁΩÆÊó•Êúü
      await prisma.users.update({
        where: { id: TEST_USER_ID },
        data: {
          freeDailyCount: 0,
          lastFreeResetDate: new Date('2023-01-01')
        }
      });

      const user = await prisma.users.upsert({
        where: { id: TEST_USER_ID },
        update: {},
        create: {
          id: TEST_USER_ID,
          telegramId: 'test_telegram_business',
          firstName: 'Test User',
          freeDailyCount: 3,
          lastFreeResetDate: new Date()
        }
      });

      // È™åËØÅÂÖçË¥πÊ¨°Êï∞Â∑≤ÈáçÁΩÆ
      expect(user.freeDailyCount).toBe(3);
      expect(new Date(user.lastFreeResetDate).toDateString()).toBe(new Date().toDateString());
    });
  });

  describe('Â§∫ÂÆùÂèÇ‰∏éÊµÅÁ®ãÊµãËØï', () => {
    test('ÊàêÂäüÂèÇ‰∏éÂ§∫ÂÆùÂ∫îËØ•Êâ£Âáè‰ΩôÈ¢ùÂπ∂Â¢ûÂä†‰ªΩÈ¢ù', async () => {
      const initialBalance = 1000;
      const initialSoldShares = 0;
      const participationCost = 10;
      const numbers = [1, 2, 3, 4, 5];

      // ÈáçÁΩÆÊµãËØïÊï∞ÊçÆ
      await prisma.users.update({
        where: { id: TEST_USER_ID },
        data: { balance: initialBalance, balanceVersion: 1 }
      });

      await prisma.lotteryRounds.update({
        where: { id: TEST_ROUND_ID },
        data: { 
          soldShares: initialSoldShares, 
          soldSharesVersion: 1,
          totalShares: 100,
          status: 'active'
        }
      });

      const result = await DatabaseLockManager.participateInLotteryWithBalanceDeduction(;
        TEST_USER_ID,
        TEST_ROUND_ID,
        TEST_PRODUCT_ID,
        participationCost,
        numbers
      );

      expect(result.success).toBe(true);
      expect(result.participationId).toBeDefined();

      // È™åËØÅ‰ΩôÈ¢ùÊâ£Âáè
      const updatedUser = await prisma.users.findUnique({
        where: { id: TEST_USER_ID }
      });
      expect(updatedUser?.balance).toBe(initialBalance - participationCost);

      // È™åËØÅ‰ªΩÈ¢ùÂ¢ûÂä†
      const updatedRound = await prisma.lotteryRounds.findUnique({
        where: { id: TEST_ROUND_ID }
      });
      expect(updatedRound?.soldShares).toBe(initialSoldShares + participationCost);

      // È™åËØÅÂèÇ‰∏éËÆ∞ÂΩï
      const participation = await prisma.participations.findUnique({
        where: { id: result.participationId! }
      });
      expect(participation).toBeDefined();
      expect(participation?.numbers).toEqual(numbers);
      expect(participation?.sharesCount).toBe(participationCost);
    });

    test('‰ΩôÈ¢ù‰∏çË∂≥Êó∂Â∫îËØ•ÊãíÁªùÂèÇ‰∏é', async () => {
      // ËÆæÁΩÆ‰ΩôÈ¢ù‰∏∫0
      await prisma.users.update({
        where: { id: TEST_USER_ID },
        data: { balance: 0, balanceVersion: 1 }
      });

      const result = await DatabaseLockManager.participateInLotteryWithBalanceDeduction(;
        TEST_USER_ID,
        TEST_ROUND_ID,
        TEST_PRODUCT_ID,
        10,
        [1, 2, 3, 4, 5]
      );

      expect(result.success).toBe(false);
      expect(result.errorMessage).toContain('‰ΩôÈ¢ù‰∏çË∂≥');
    });

    test('‰ªΩÈ¢ù‰∏çË∂≥Êó∂Â∫îËØ•ÊãíÁªùÂèÇ‰∏é', async () => {
      // ËÆæÁΩÆÂâ©‰Ωô‰ªΩÈ¢ù‰∏∫2
      await prisma.lotteryRounds.update({
        where: { id: TEST_ROUND_ID },
        data: { 
          soldShares: 98, 
          soldSharesVersion: 1,
          totalShares: 100,
          status: 'active'
        }
      });

      const result = await DatabaseLockManager.participateInLotteryWithBalanceDeduction(;
        TEST_USER_ID,
        TEST_ROUND_ID,
        TEST_PRODUCT_ID,
        5, // Â∞ùËØï‰π∞5‰ªΩÔºå‰ΩÜÂè™Ââ©2‰ªΩ
        [1, 2, 3, 4, 5]
      );

      expect(result.success).toBe(false);
      expect(result.errorMessage).toContain('‰ªΩÈ¢ù‰∏çË∂≥');
    });

    test('ÈùûÊ¥ªË∑ÉËΩÆÊ¨°Â∫îËØ•ÊãíÁªùÂèÇ‰∏é', async () => {
      // ËÆæÁΩÆËΩÆÊ¨°‰∏∫Â∑≤ÂÆåÊàê
      await prisma.lotteryRounds.update({
        where: { id: TEST_ROUND_ID },
        data: { status: 'completed' }
      });

      const result = await DatabaseLockManager.participateInLotteryWithBalanceDeduction(;
        TEST_USER_ID,
        TEST_ROUND_ID,
        TEST_PRODUCT_ID,
        1,
        [1]
      );

      expect(result.success).toBe(false);
      expect(result.errorMessage).toContain('‰∏çÊòØÊ¥ªË∑ÉÁä∂ÊÄÅ');
    });
  });

  describe('ËÆ¢ÂçïÁÆ°ÁêÜÊµÅÁ®ãÊµãËØï', () => {
    test('ÂàõÂª∫ËÆ¢ÂçïÂ∫îËØ•ÊàêÂäü', async () => {
      const orderNumber = `ORDER_${Date.now()}`;
      const totalAmount = 99.99;

      const order = await prisma.orders.create({
        data: {
          orderNumber,
          userId: TEST_USER_ID,
          type: 'lottery',
          totalAmount,
          status: 'pending',
          quantity: 1
        }
      });

      expect(order).toBeDefined();
      expect(order.orderNumber).toBe(orderNumber);
      expect(order.totalAmount).toBe(totalAmount);
      expect(order.status).toBe('pending');
    });

    test('ËÆ¢ÂçïÁä∂ÊÄÅÊõ¥Êñ∞Â∫îËØ•ÂéüÂ≠êÊÄß', async () => {
      // ÂàõÂª∫ÊµãËØïËÆ¢Âçï
      const order = await prisma.orders.create({
        data: {
          orderNumber: `TEST_ORDER_${Date.now()}`,
          userId: TEST_USER_ID,
          type: 'lottery',
          totalAmount: 100,
          status: 'pending',
          version: 1
        }
      });

      const result = await DatabaseLockManager.updateOrderStatusWithLock(;
        order.id,
        'completed'
      );

      expect(result.success).toBe(true);

      // È™åËØÅÁä∂ÊÄÅÊõ¥Êñ∞
      const updatedOrder = await prisma.orders.findUnique({
        where: { id: order.id }
      });

      expect(updatedOrder?.status).toBe('completed');
    });

    test('ÁâàÊú¨ÂÜ≤Á™ÅÂ∫îËØ•ÈòªÊ≠¢Âπ∂ÂèëÊõ¥Êñ∞', async () => {
      const order = await prisma.orders.create({
        data: {
          orderNumber: `CONCURRENT_TEST_${Date.now()}`,
          userId: TEST_USER_ID,
          type: 'lottery',
          totalAmount: 100,
          status: 'pending',
          version: 1
        }
      });

      // Á¨¨‰∏ÄÊ¨°Êõ¥Êñ∞ÊàêÂäü
      const result1 = await DatabaseLockManager.updateOrderStatusWithLock(;
        order.id,
        'completed'
      );
      expect(result1.success).toBe(true);

      // Ê®°ÊãüÁâàÊú¨ÂÜ≤Á™Å
      await prisma.orders.update({
        where: { id: order.id },
        data: { version: { decrement: 1 } }
      });

      // Á¨¨‰∫åÊ¨°Êõ¥Êñ∞Â∫îËØ•Â§±Ë¥•
      const result2 = await DatabaseLockManager.updateOrderStatusWithLock(;
        order.id,
        'cancelled'
      );

      expect(result2.success).toBe(false);
      expect(result2.errorMessage).toContain('ÁâàÊú¨ÂÜ≤Á™Å');
    });
  });

  describe('ÂºÄÂ•ñÊµÅÁ®ãÊµãËØï', () => {
    test('ÂºÄÂ•ñÂ∫îËØ•ÁîüÊàêÊúâÊïàÁöÑËé∑ËÉúÂè∑Á†Å', async () => {
      // ÂàõÂª∫ÂèÇ‰∏éËÆ∞ÂΩï
      const participations = [;
        {
          id: 'part-1',
          userId: TEST_USER_ID,
          numbers: [1, 2, 3, 4, 5],
          amount: 5,
          createdAt: new Date()
        }
      ];

      const totalShares = 100;
      const drawResult = await performSecureDraw(participations, totalShares);

      expect(drawResult).toBeDefined();
      expect(drawResult.winningNumber).toBeGreaterThanOrEqual(10000001);
      expect(drawResult.winningNumber).toBeLessThanOrEqual(10000000 + totalShares);
      expect(drawResult.A).toBeDefined();
      expect(drawResult.B).toBeDefined();
      expect(drawResult.C).toBeDefined();
    });

    test('Êª°ÂëòËΩÆÊ¨°Â∫îËØ•Ëá™Âä®ÂºÄÂ•ñ', async () => {
      // ËÆæÁΩÆËΩÆÊ¨°‰∏∫Êª°Âëò
      await prisma.lotteryRounds.update({
        where: { id: TEST_ROUND_ID },
        data: { 
          soldShares: 100, 
          soldSharesVersion: 1,
          totalShares: 100,
          status: 'active'
        }
      });

      // È™åËØÅËΩÆÊ¨°Áä∂ÊÄÅ
      const round = await prisma.lotteryRounds.findUnique({
        where: { id: TEST_ROUND_ID }
      });

      expect(round?.soldShares).toBe(round?.totalShares);
      expect(round?.status).toBe('active');
    });

    test('‰∏≠Â•ñÂêéÂ∫îËØ•ÂàõÂª∫‰∏≠Â•ñËÆ¢Âçï', async () => {
      // Ê®°ÊãüÂºÄÂ•ñÁªìÊûú
      const winningNumber = 10000015;
      const winnerUserId = TEST_USER_ID;

      // Êü•ÊâæËØ•Áî®Êà∑ÁöÑ‰∏≠Â•ñÂèÇ‰∏éËÆ∞ÂΩï
      const winningParticipation = await prisma.participations.findFirst({
        where: {
          userId: winnerUserId,
          numbers: { has: winningNumber % 10000000 } // ÁÆÄÂåñÂåπÈÖçÈÄªËæë
        }
      });

      if (winningParticipation) {
        // ÂàõÂª∫‰∏≠Â•ñËÆ¢Âçï
        const order = await prisma.orders.create({
          data: {
            orderNumber: `WIN_${Date.now()}`,
            userId: winnerUserId,
            type: 'win',
            totalAmount: 9999, // ÂÅáËÆæÂ•ñÂìÅ‰ª∑ÂÄº
            status: 'pending',
            lotteryRoundId: TEST_ROUND_ID,
            winningNumber
          }
        });

        expect(order).toBeDefined();
        expect(order.type).toBe('win');
        expect(order.winningNumber).toBe(winningNumber);
      }
    });
  });

  describe('‰∫§ÊòìËÆ∞ÂΩïÊµÅÁ®ãÊµãËØï', () => {
    test('‰ΩôÈ¢ùÂèòÂåñÂ∫îËØ•ËÆ∞ÂΩï‰∫§Êòì', async () => {
      const initialBalance = 1000;
      const amount = 100;
      const transactionType = 'lottery_participation';

      await prisma.users.update({
        where: { id: TEST_USER_ID },
        data: { balance: initialBalance, balanceVersion: 1 }
      });

      // Ê®°ÊãüÊâ£Âáè‰ΩôÈ¢ùÊìç‰Ωú
      await prisma.users.update({
        where: { id: TEST_USER_ID },
        data: { 
          balance: { decrement: amount },
          balanceVersion: { increment: 1 }
        }
      });

      // ËÆ∞ÂΩï‰∫§Êòì
      const transaction = await prisma.transactions.create({
        data: {
          userId: TEST_USER_ID,
          type: transactionType,
          amount: -amount,
          description: 'ÂèÇ‰∏éÂ§∫ÂÆù',
          balanceAfter: initialBalance - amount
        }
      });

      expect(transaction).toBeDefined();
      expect(transaction.amount).toBe(-amount);
      expect(transaction.type).toBe(transactionType);
      expect(transaction.userId).toBe(TEST_USER_ID);
    });

    test('ÂÖÖÂÄºÂ∫îËØ•ËÆ∞ÂΩïÊ≠£Âêë‰∫§Êòì', async () => {
      const rechargeAmount = 500;

      const transaction = await prisma.transactions.create({
        data: {
          userId: TEST_USER_ID,
          type: 'recharge',
          amount: rechargeAmount,
          description: 'Áî®Êà∑ÂÖÖÂÄº',
          balanceAfter: 1500 // ÂÅáËÆæÂÖÖÂÄºÂâç‰ΩôÈ¢ù‰∏∫1000
        }
      });

      expect(transaction.amount).toBe(rechargeAmount);
      expect(transaction.type).toBe('recharge');
      expect(transaction.balanceAfter).toBe(1500);
    });

    test('ÊèêÁé∞Â∫îËØ•ËÆ∞ÂΩïË¥üÂêë‰∫§Êòì', async () => {
      const withdrawAmount = 200;

      const transaction = await prisma.transactions.create({
        data: {
          userId: TEST_USER_ID,
          type: 'withdraw',
          amount: -withdrawAmount,
          description: 'Áî®Êà∑ÊèêÁé∞',
          balanceAfter: 800 // ÂÅáËÆæÊèêÁé∞Ââç‰ΩôÈ¢ù‰∏∫1000
        }
      });

      expect(transaction.amount).toBe(-withdrawAmount);
      expect(transaction.type).toBe('withdraw');
      expect(transaction.balanceAfter).toBe(800);
    });
  });

  describe('ÂÖçË¥πÊ¨°Êï∞ÁÆ°ÁêÜÊµãËØï', () => test('ÂÖçË¥πÊ¨°Êï∞ÈáçÁΩÆÂ∫îËØ•Ê≠£Â∏∏Â∑•‰Ωú', async () => {
      // ËÆæÁΩÆÊóßÁöÑÂÖçË¥πÊ¨°Êï∞
      await prisma.users.update({
        where: { id: TEST_USER_ID },
        data: {
          freeDailyCount: 0,
          lastFreeResetDate: new Date(Date.now() - 24 * 60 * 60 * 1000) // Êò®Â§©
        }
      });

      const result = await DatabaseLockManager.resetUserFreeCountSafe(TEST_USER_ID);

      expect(result).toBe(true);

      // È™åËØÅÈáçÁΩÆÁªìÊûú
      const user = await prisma.users.findUnique({
        where: { id: TEST_USER_ID }
      });

      expect(user?.freeDailyCount).toBe(3);
      expect(new Date(user?.lastFreeResetDate!).toDateString()).toBe(new Date().toDateString());
    })
  );

  describe('‰∏öÂä°ËßÑÂàôÈ™åËØÅÊµãËØï', () => {
    test('Áî®Êà∑‰ΩôÈ¢ù‰∏çËÉΩ‰∏∫Ë¥ü', async () => {
      const result = await DatabaseLockManager.updateUserBalanceWithOptimisticLock(;
        TEST_USER_ID,
        10000, // Ë∂ÖËøáÂΩìÂâç‰ΩôÈ¢ù
        'deduct',
        'balance'
      );

      expect(result.success).toBe(false);
      expect(result.errorMessage).toContain('‰ΩôÈ¢ù‰∏çË∂≥');
    });

    test('Â§∫ÂÆù‰ªΩÈ¢ù‰∏çËÉΩË∂ÖËøáÊÄª‰ªΩÈ¢ù', async () => {
      await prisma.lotteryRounds.update({
        where: { id: TEST_ROUND_ID },
        data: { 
          soldShares: 90,
          soldSharesVersion: 1,
          totalShares: 100
        }
      });

      const result = await DatabaseLockManager.updateLotteryRoundSoldSharesWithLock(;
        TEST_ROUND_ID,
        20 // Ë∂ÖËøáÂâ©‰Ωô‰ªΩÈ¢ù
      );

      expect(result.success).toBe(false);
      expect(result.errorMessage).toContain('‰ªΩÈ¢ù‰∏çË∂≥');
    });

    test('ÂÖçË¥πÂèÇ‰∏éÊ¨°Êï∞‰∏çËÉΩË∂ÖËøáÈôêÂà∂', async () => {
      // ËÆæÁΩÆÂÖçË¥πÊ¨°Êï∞‰∏∫0
      await prisma.users.update({
        where: { id: TEST_USER_ID },
        data: { freeDailyCount: 0 }
      });

      // ËøôÈáåÂ∫îËØ•Ê£ÄÊü•‰∏öÂä°ÈÄªËæëÔºåÂÖçË¥πÊ¨°Êï∞‰∏∫0Êó∂‰∏çÂÖÅËÆ∏ÂÖçË¥πÂèÇ‰∏é
      const user = await prisma.users.findUnique({
        where: { id: TEST_USER_ID }
      });

      expect(user?.freeDailyCount).toBe(0);
    });
  });

  describe('Âπ∂Âèë‰∏öÂä°Âú∫ÊôØÊµãËØï', () => test('Â§ö‰∏™Áî®Êà∑ÂêåÊó∂ÂèÇ‰∏éÂ∫îËØ•Ê≠£Á°ÆÂ§ÑÁêÜ', async () => {
      const concurrentUsers = Array(10).fill(0).map((_, i) => `concurrent-user-${i}`);
      
      // ÂàõÂª∫Âπ∂ÂèëÁî®Êà∑
      for (const userId of concurrentUsers) {
        await prisma.users.upsert({
          where: { id: userId },
          update: { balance: 100, balanceVersion: 1 },
          create: {
            id: userId,
            telegramId: `concurrent_${userId}`,
            firstName: `User ${userId}`,
            balance: 100,
            balanceVersion: 1
          }
        });
      }

      const operations = concurrentUsers.map(userId =>;
        DatabaseLockManager.participateInLotteryWithBalanceDeduction(
          userId,
          TEST_ROUND_ID,
          TEST_PRODUCT_ID,
          5,
          [1, 2, 3, 4, 5]
        )
      );

      const results = await Promise.all(operations);
      const successCount = results.filter(result => result.success).length;

      // È™åËØÅÊÄª‰ªΩÈ¢ù‰∏çË∂ÖËøáÈôêÂà∂
      const finalRound = await prisma.lotteryRounds.findUnique({
        where: { id: TEST_ROUND_ID }
      });

      expect(finalRound?.soldShares).toBeLessThanOrEqual(finalRound?.totalShares);
      expect(successCount).toBeGreaterThan(0);

      console.log(`   ‚úÖ ÊàêÂäüÂ§ÑÁêÜ ${successCount}/${concurrentUsers.length} ‰∏™Âπ∂ÂèëÂèÇ‰∏é`);
    })
  );
});

// ËæÖÂä©ÂáΩÊï∞
async function setupBusinessTestData() {
  // ÂàõÂª∫ÊµãËØïÁî®Êà∑
  await prisma.users.upsert({
    where: { id: TEST_USER_ID },
    update: {
      balance: 1000,
      balanceVersion: 1,
      platformBalance: 500,
      platformBalanceVersion: 1,
      freeDailyCount: 3,
      lastFreeResetDate: new Date()
    },
    create: {
      id: TEST_USER_ID,
      telegramId: 'test_telegram_business',
      firstName: 'Business Test User',
      balance: 1000,
      balanceVersion: 1,
      platformBalance: 500,
      platformBalanceVersion: 1,
      freeDailyCount: 3,
      lastFreeResetDate: new Date()
    }
  });

  // ÂàõÂª∫ÊµãËØïÂïÜÂìÅ
  await prisma.products.upsert({
    where: { id: TEST_PRODUCT_ID },
    update: {},
    create: {
      id: TEST_PRODUCT_ID,
      nameZh: 'ÊµãËØïÂïÜÂìÅ',
      nameEn: 'Test Product',
      nameRu: '–¢–µ—Å—Ç–æ–≤—ã–π —Ç–æ–≤–∞—Ä',
      descriptionZh: 'ËøôÊòØ‰∏Ä‰∏™ÊµãËØïÂïÜÂìÅ',
      price: 99.99,
      status: 'active',
      isActive: true
    }
  });

  // ÂàõÂª∫ÊµãËØïÂ§∫ÂÆùËΩÆÊ¨°
  await prisma.lotteryRounds.upsert({
    where: { id: TEST_ROUND_ID },
    update: {
      totalShares: 100,
      soldShares: 0,
      soldSharesVersion: 1,
      status: 'active'
    },
    create: {
      id: TEST_ROUND_ID,
      productId: TEST_PRODUCT_ID,
      roundNumber: 1,
      totalShares: 100,
      soldShares: 0,
      soldSharesVersion: 1,
      status: 'active'
    }
  });
}

async function resetBusinessTestData() {
  // ÈáçÁΩÆÁî®Êà∑‰ΩôÈ¢ùÂíåÁâàÊú¨
  await prisma.users.update({
    where: { id: TEST_USER_ID },
    data: { 
      balance: 1000, 
      balanceVersion: 1,
      platformBalance: 500,
      platformBalanceVersion: 1,
      freeDailyCount: 3
    }
  });

  // ÈáçÁΩÆËΩÆÊ¨°‰ªΩÈ¢ù
  await prisma.lotteryRounds.update({
    where: { id: TEST_ROUND_ID },
    data: { 
      soldShares: 0, 
      soldSharesVersion: 1,
      status: 'active',
      winningNumber: null
    }
  });
}

async function cleanupBusinessTestData() {
  try {
    // Ê∏ÖÁêÜÊµãËØïÊï∞ÊçÆ
    await prisma.participations.deleteMany({ where: { userId: TEST_USER_ID } });
    await prisma.transactions.deleteMany({ where: { userId: TEST_USER_ID } });
    await prisma.orders.deleteMany({ where: { userId: TEST_USER_ID } });
    await prisma.lotteryRounds.deleteMany({ where: { id: TEST_ROUND_ID } });
    await prisma.products.deleteMany({ where: { id: TEST_PRODUCT_ID } });
    await prisma.users.deleteMany({ where: { id: TEST_USER_ID } });
  } catch (error) {
    console.error('Ê∏ÖÁêÜ‰∏öÂä°ÊµãËØïÊï∞ÊçÆÊó∂Âá∫Èîô:', error);
  }
}